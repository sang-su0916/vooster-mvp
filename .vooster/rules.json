{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구 사항 문서 (PRD)\n\n## 1. 개요\n사내 직원이 이름·사번만 입력하면 근로계약서, 임금대장, 직원명부 등 필수 인사·노무 서류를 즉시 발급∙다운로드∙인쇄할 수 있는 웹 기반 자동 서류 발급 시스템. 관리 부서의 업무 부담을 대폭 감소시키고, 직원에게 셀프서비스 경험을 제공한다.\n\n## 2. 문제 정의\n- 인사팀은 반복적으로 서류를 작성·출력하는 데 과도한 시간을 사용\n- 서류 양식 통일 미흡으로 법적 리스크 증가\n- 직원이 서류 요청 시 대기 시간이 길어 업무 효율 저하\n- 전자 문서/서명 기능 부재로 종이 문서 관리 비용 발생\n\n## 3. 목표 및 목적\n- 주요 목표: 사내 서류 발급 업무를 90% 이상 자동화\n- 부가 목표\n  - 직원 만족도(NPS) +30 ↑\n  - 법적 서류 양식 100% 최신 유지\n  - 관리자 작업 시간 1건당 5분→30초 단축\n- 성공 지표\n  - 월간 발급 건수\n  - 평균 발급 소요 시간\n  - 사용 직원 비율\n  - 시스템 오류율 <0.5%\n\n## 4. 대상 사용자\n### 주요 사용자\n- 일반 직원: 개인 서류 셀프 발급, 모바일·PC 모두 사용\n- 인사·총무팀: 서류 템플릿 관리, 승인·감사 대응\n### 이해관계자\n- 경영진: 업무 효율·비용 절감\n- 감사·노무 법무팀: 법적 컴플라이언스 확보\n- IT팀: 시스템 유지보수\n\n## 5. 사용자 스토리\n- 직원으로서, 이름과 사번만 입력해 근로계약서를 PDF로 즉시 다운로드하고 싶다.\n- 인사담당으로서, 업데이트된 법정 서식이 자동 반영된 템플릿을 관리하고 싶다.\n- 휴대폰으로 서류를 열람하는 직원으로서, 모바일 최적화된 화면을 보고 싶다.\n- 경영진으로서, 발급 통계 리포트를 실시간 확인해 인사 업무 효율을 판단하고 싶다.\n\n## 6. 기능 요구 사항\n### 핵심 기능\n1. 서류 자동 생성\n   - 템플릿 + DB 인사정보 매핑\n   - 조건: 이름·사번 입력 시 미리보기 3초 이내 제공\n2. 다중 서류 종류 지원\n   - 근로계약서, 임금대장, 직원명부 초기 제공\n   - Acceptance: 각 서류별 필드 100% 매핑 테스트 통과\n3. PDF/인쇄/전자서명\n   - PDF 다운로드, 브라우저 인쇄\n   - 전자서명 연동(간편서명, 공인인증)\n4. 접근 권한 관리\n   - 직원은 본인 서류만, 인사팀은 전체 접근\n   - SSO·사내 AD 연동\n5. 감사 로그\n   - 발급·열람·변경 이벤트 전부 저장, 1년 보존\n6. 다국어/통화 지원(선택)\n   - 한국어 기본, 영어 옵션\n\n### 지원 기능\n- 서류 발급 요청 이력 조회\n- 관리자 대시보드(발급 통계, 오류 알림)\n- 템플릿 버전 관리 및 롤백\n- 알림: 메신저·이메일 링크 전송\n- 모바일 반응형 UI\n\n## 7. 비기능 요구 사항\n- 성능: 100건 동시 발급 시 95퍼센타일 응답 <2초\n- 보안: TLS 1.3, 개인정보 AES-256 at rest\n- 사용성: WCAG 2.1 AA\n- 확장성: 연 20% 사용자 증가 대비\n- 호환성: 최신 Chrome, Edge, Safari, 모바일 브라우저\n\n## 8. 기술 고려 사항\n- 아키텍처: React(Next.js)+Node.js(NestJS) or Spring Boot, REST/GraphQL API, AWS ECS\n- DB: PostgreSQL(인사 데이터), S3(PDF 저장)\n- 인사 시스템 연동: REST API 또는 SFTP\n- 전자서명: eSign SaaS(비대면), 사내 인증서 모듈 옵션\n- CI/CD: GitHub Actions, Terraform IaC\n- PDF 생성: openhtmltopdf or jsPDF\n\n## 9. 성공 지표·KPI\n- 월간 활성 사용자(MAU) ≥ 전체 직원 80%\n- 평균 발급 시간 <5초\n- 오류 재시도율 <1%\n- 인사팀 업무 시간 90%↓ (조사 설문)\n\n## 10. 일정 및 마일스톤\n- Phase 1 (MVP) – 3개월\n  - 사용자 인증, 템플릿 3종, PDF 다운로드\n- Phase 2 – 2개월\n  - 전자서명, 관리자 대시보드, 감사 로그\n- Phase 3 – 2개월\n  - 다국어, 모바일 전면 최적화, AI 문서 추천\n\n## 11. 위험 및 대응\n- 법적 서식 변경 빈번: 정부 고시 모니터링 자동화\n- 개인정보 유출: 정기 침투 테스트, 권한 최소화\n- 사용자 채택 저조: 온보딩 가이드, 교육 세션\n- 시스템 부하: 오토스케일링, 캐싱\n\n## 12. 향후 고려 사항\n- AI 챗봇: 필요한 서류 추천 및 발급 안내\n- HRIS 전면 통합으로 인사 데이터 실시간 동기화\n- 조직도 기반 자동 권한 설정\n- 블록체인 기반 위·변조 방지 스탬프 적용",
      "writedAt": "2025-07-19T08:17:17.562Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **프로젝트 개요**  \n  사내 직원이 이름·사번만 입력하면 근로계약서, 임금대장, 직원명부 등 필수 인사·노무 서류를 즉시 발급·다운로드·인쇄할 수 있는 웹 기반 시스템. Next.js 기반 프론트엔드와 NestJS 기반 백엔드를 AWS ECS 위에 배포하고, PostgreSQL·S3를 사용해 데이터와 PDF를 관리합니다.\n- **핵심 기술 스택**  \n  · 프론트엔드: Next.js (React)  \n  · 백엔드: NestJS (Node.js)  \n  · 데이터베이스: PostgreSQL (RDS)  \n  · 파일 스토리지: AWS S3  \n  · PDF 생성: openhtmltopdf  \n  · 인증·인가: 사내 AD 연동 SSO (OAuth2, OpenID Connect)  \n  · 배포·인프라: AWS ECS, Terraform, GitHub Actions\n- **주요 기술 목표**  \n  · 95퍼센타일 응답 시간 <2초 (100건 동시)  \n  · 시스템 오류율 <0.5%  \n  · 무중단 배포·오토스케일링  \n  · 개인정보 암호화(AES-256 at rest), TLS 1.3\n- **핵심 가정 사항**  \n  · 사내 AD/SSO 통합 가능  \n  · 템플릿 및 인사 데이터 초기 적재 완료  \n  · AWS 계정 및 네트워크(VPC, Subnet) 기본 구성 완료  \n\n---\n\n## 2. Tech Stack\n\n| Category             | Technology / Library      | Reasoning (선택 이유)                                                 |\n| -------------------- | ------------------------- | --------------------------------------------------------------------- |\n| Frontend Framework   | Next.js                   | React 기반 SSR/SSG 지원, SEO 및 초기 렌더링 최적화                     |\n| Styling / UI Toolkit | Tailwind CSS              | 유연한 디자인 시스템, 빠른 스타일링                                   |\n| State Management     | React Query               | 서버 상태 캐싱 및 데이터 페칭 최적화                                   |\n| Backend Framework    | NestJS                     | 모듈화·유연한 구조, 데코레이터 기반, 확장성 우수                       |\n| Language             | TypeScript                | 정적 타입으로 가독성·안정성 확보                                      |\n| API Design           | REST (OpenAPI)            | 표준화된 인터페이스, Swagger 문서 자동 생성                           |\n| Database             | PostgreSQL (RDS)          | ACID 보장, JSONB 지원, 확장성·신뢰성                                   |\n| ORM                  | TypeORM                   | NestJS 공식 지원, Entity 기반 코드 조직화                              |\n| File Storage         | AWS S3                    | 내구성·확장성 우수, 비용 효율적                                       |\n| PDF Generation       | openhtmltopdf             | HTML/CSS 템플릿에서 정확한 PDF 출력                                    |\n| Authentication       | OAuth2 / OpenID Connect   | 사내 AD SSO 연동, 권한 관리 편리                                       |\n| Electronic Signature | eSign SaaS API            | 검증된 전자서명 제공, 개발 부담 최소화                                 |\n| CI/CD                | GitHub Actions            | Git 연동 파이프라인, 코드 퀄리티·배포 자동화                           |\n| Infrastructure IaC   | Terraform                 | 인프라 코드화, 재현 가능 · 버전 관리                                   |\n| Container Orchestration | AWS ECS                 | 관리형 컨테이너 서비스, 오토스케일링 지원                              |\n| Monitoring / Logging | Prometheus & Grafana, ELK | 실시간 모니터링·로그 검색·알람 체계 구축                              |\n| Notification         | Amazon SES / Slack API    | 이메일·메신저 알림 자동화                                             |\n\n---\n\n## 3. System Architecture Design\n\n### Top-Level Building Blocks\n- 프론트엔드 (Next.js)  \n  · SSR/CSR 혼합 렌더링, React Query를 통한 데이터 페칭  \n  · 모바일·PC 반응형 UI\n- 백엔드 API (NestJS)  \n  · REST API 컨트롤러·서비스·레포지토리 구조  \n  · 인증·인가 모듈, 문서 생성·관리 모듈, 감사 로그 모듈\n- 데이터 저장소  \n  · RDS PostgreSQL: 인사 데이터·템플릿 버전 관리  \n  · S3 버킷: 생성된 PDF 파일 영구 보관\n- 인증·인가  \n  · OAuth2/OpenID Connect 기반 AD SSO 연동  \n  · 권한(Role-Based Access Control)\n- 외부 서비스  \n  · eSign SaaS: 전자서명 처리  \n  · 메신저·이메일 API: 알림 전송\n- 인프라 및 운영  \n  · AWS ECS (Fargate) 컨테이너 배포  \n  · Terraform IaC, GitHub Actions CI/CD  \n  · Prometheus·Grafana 모니터링, ELK 로그스택\n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n    A[Frontend (Next.js)] -->|REST API 호출| B[Backend (NestJS)]\n    B -->|SQL Query| C[(PostgreSQL)]\n    B -->|파일 업로드/다운로드| D[(S3)]\n    B -->|전자서명 요청| E[eSign SaaS]\n    B -->|SSO 인증| F[사내 AD]\n    B -->|로그 수집| G[ELK Stack]\n    H[Monitoring] --> B\n```\n\n- 직원·관리자는 Next.js UI에서 인증 후 백엔드 API 호출  \n- 백엔드는 PostgreSQL에서 인사정보 조회·템플릿 매핑 후 openhtmltopdf로 PDF 생성  \n- 생성된 PDF를 S3에 저장·버전 관리  \n- 전자서명 요청은 eSign SaaS API로 연동  \n- 발급·열람·변경 이벤트는 ELK 스택으로 전송, Prometheus/Grafana에서 지표 수집\n\n### Code Organization & Convention\n\n**Domain-Driven Organization Strategy**  \n- Domain Separation  \n  · User (인증·권한)  \n  · Document (템플릿·발급)  \n  · Audit (감사용 로그)  \n  · Admin (통계·템플릿 관리)  \n- Layer-Based Architecture  \n  · Presentation Layer (Controller)  \n  · Business Logic Layer (Service)  \n  · Data Access Layer (Repository / Entity)  \n  · Infrastructure Layer (External API, S3, eSign, DB Connection)  \n- Feature-Based Modules  \n  · 각 도메인은 독립 NestJS 모듈  \n- Shared Components  \n  · 공통 유틸리티, DTO, 인터셉터, 예외 필터 등\n\n**Universal File & Folder Structure**\n```\n/\n├── src\n│   ├── main.ts\n│   ├── app.module.ts\n│   ├── common\n│   │   ├── filters\n│   │   ├── interceptors\n│   │   └── dto\n│   ├── config\n│   ├── modules\n│   │   ├── auth\n│   │   │   ├── auth.controller.ts\n│   │   │   ├── auth.service.ts\n│   │   │   └── auth.module.ts\n│   │   ├── user\n│   │   ├── document\n│   │   ├── audit\n│   │   └── admin\n│   └── infrastructure\n│       ├── db\n│       ├── s3\n│       └── esign\n├── templates\n│   └── *.html\n├── public\n│   └── assets\n└── terraform\n    ├── main.tf\n    └── variables.tf\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: Next.js → NestJS REST API, JWT 또는 OAuth2 토큰 사용  \n- **Database Interaction**: TypeORM 기반 Repository, 커넥션 풀링, 인덱싱  \n- **External Service Integration**: Axios를 통한 eSign SaaS, SES/Slack API 호출  \n- **Real-time Communication**: Webhook 수신(전자서명 완료 콜백)  \n- **Data Synchronization**: S3 업로드 후 DB에 메타데이터 저장, 템플릿 버전 관리\n\n---\n\n## 4. Performance & Optimization Strategy\n- API 응답 캐싱: Redis 적용 고려 (문서 미변경 시)  \n- 데이터베이스 인덱스·쿼리 튜닝: 자주 조회되는 컬럼 인덱스 추가  \n- 비동기 작업 처리: PDF 생성·전자서명 처리는 메시지 큐(AWS SQS) 활용  \n- 오토스케일링: AWS ECS Fargate CPU/메모리 기반 오토스케일 정책  \n\n---\n\n## 5. Implementation Roadmap & Milestones\n\n### Phase 1: Foundation (MVP 구현, 3개월)\n- Core Infrastructure: Terraform으로 VPC, ECS 클러스터, RDS, S3 배포  \n- Essential Features:  \n  · SSO 로그인/권한 관리  \n  · 템플릿 3종(근로계약서·임금대장·직원명부) PDF 생성·다운로드  \n  · React Query 기반 미리보기 (3초 이내)  \n- Basic Security: TLS 설정, DB 암호화  \n- Development Setup: GitHub Actions CI/CD 파이프라인  \n- Timeline: 3개월\n\n### Phase 2: Feature Enhancement (2개월)\n- Advanced Features: 전자서명 연동, 관리자 대시보드(발급 통계, 오류 알림)  \n- Performance Optimization: 메시지 큐 기반 비동기 처리  \n- Enhanced Security: OWASP 점검, 정기 침투 테스트  \n- Monitoring Implementation: Prometheus·Grafana, ELK 알림  \n- Timeline: 2개월\n\n### Phase 3: Scaling & Optimization (2개월)\n- Scalability Implementation: Redis 캐싱, ECS 클러스터 Autoscaling  \n- Advanced Integrations: 다국어(영어), AI 문서 추천 PoC  \n- Enterprise Features: 조직도 기반 권한 설정, 템플릿 롤백  \n- Compliance & Auditing: 감사 로그 1년 보존 정책 자동화  \n- Timeline: 2개월\n\n---\n\n## 6. Risk Assessment & Mitigation Strategies\n\n### Technical Risk Analysis\n- Technology Risks  \n  · NestJS·Next.js 신규 도입 학습 곡선 → 초기 교육 세션 진행  \n- Performance Risks  \n  · 대량 PDF 생성 부하 → 비동기 큐 처리, 오토스케일링  \n- Security Risks  \n  · 개인정보 유출 → AES-256 at rest, 권한 최소화  \n- Integration Risks  \n  · eSign SaaS API 변경 → 계약 시 버전 고정, 테스트 자동화  \n- Mitigation Strategies  \n  · 기술 워크숍, 부하 테스트, 정기 보안 점검, 회귀 테스트 자동화\n\n### Project Delivery Risks\n- Timeline Risks  \n  · 주요 기능 지연 → 명확한 마일스톤·데일리 스탠드업  \n- Resource Risks  \n  · 백엔드·프론트 인력 부족 → 크로스 트레이닝, 외부 컨설팅 가능성 검토  \n- Quality Risks  \n  · 테스트 커버리지 부족 → Jest·Supertest 기반 단위·통합 테스트  \n- Deployment Risks  \n  · 프로덕션 환경 이슈 → 단계별 Canary 배포, 롤백 자동화  \n- Contingency Plans  \n  · 외부 전문가 자문, 기능 우선순위 재조정, 추가 리소스 투입  \n\n---\n\n**끝**",
      "writedAt": "2025-07-19T08:17:17.563Z"
    },
    {
      "type": "guideline",
      "content": "# Code Guideline Document\n\n## 1. Project Overview  \nThis project delivers a web‐based automated document issuance system using:  \n- Frontend: Next.js (React + TypeScript), Tailwind CSS, React Query  \n- Backend: NestJS (Node.js + TypeScript), REST (OpenAPI), TypeORM  \n- Database: PostgreSQL (RDS)  \n- File Storage: AWS S3 (PDF assets)  \n- PDF Generation: openhtmltopdf  \n- Auth: OAuth2/OpenID Connect via AD SSO  \n- Infra & CI/CD: AWS ECS (Fargate), Terraform, GitHub Actions  \nKey decisions:  \n- Domain‐driven, feature‐based NestJS modules  \n- SSR/CSR hybrid Next.js with per‐page caching via React Query  \n- Secure, typed APIs with Swagger‐driven OpenAPI  \n\n## 2. Core Principles  \n1. Single Responsibility: each file or module must serve one feature or domain and remain under 200 lines.  \n2. Strict Typing: forbid `any`; all public functions and API DTOs require explicit TypeScript types.  \n3. Automated Testing: each controller/service and React hook must include ≥80% unit‐test coverage.  \n4. Declarative Data Flow: use React Query for all server state, avoid ad‐hoc `useState` for remote data.  \n5. Consistent Error Handling: all errors propagate through a centralized filter/interceptor.  \n\n## 3. Language-Specific Guidelines  \n\n### 3.1 Next.js (TypeScript + React)  \n- Folder Layout:  \n  ```\n  /src\n  ├─ pages           ← Next.js pages\n  ├─ components      ← Reusable UI components\n  ├─ hooks           ← Custom React hooks (React Query)\n  ├─ services        ← API client modules\n  ├─ styles          ← Tailwind CSS configs\n  └─ utils           ← Shared utilities\n  ```  \n- Imports:  \n  - Use absolute imports via `tsconfig.json` `paths`.  \n  - Group: React / Next → external libs → src aliases → styles/assets.  \n- Error Handling:  \n  - Wrap API calls in try/catch and return standardized `ApiError` object.  \n  - Use a global _error boundary_ at `pages/_app.tsx`.  \n\n### 3.2 NestJS (TypeScript)  \n- Folder Layout:  \n  ```\n  /src\n  ├─ modules\n  │  ├─ auth\n  │  ├─ document\n  │  ├─ audit\n  │  └─ admin\n  ├─ common            ← filters, interceptors, DTOs  \n  ├─ config            ← configuration modules  \n  ├─ infrastructure    ← S3/SQS/esign clients  \n  └─ main.ts  \n  ```  \n- Imports:  \n  - Use TypeScript path aliases (`@modules`, `@common`, `@infra`).  \n  - Avoid relative imports deeper than two levels.  \n- Error Handling:  \n  - Use built-in Exceptions (`BadRequestException`, `NotFoundException`).  \n  - All controllers must use `@UseFilters(new AllExceptionsFilter())`.  \n  - Unhandled errors propagate to `exceptionFilter` for logging.  \n\n## 4. Code Style Rules  \n\n### MUST Follow  \n1. **Explicit Types**  \n   - Rationale: improves readability & compile‐time safety.  \n   ```ts\n   // MUST\n   async function fetchUser(id: string): Promise<UserDto> {\n     return this.userService.findById(id);\n   }\n   ```  \n2. **Single‐Purpose Components/Services**  \n   - Rationale: easier testing, maintenance.  \n   ```ts\n   // MUST: one controller per resource\n   @Controller('documents')\n   export class DocumentController {\n     constructor(private readonly docService: DocumentService) {}\n     @Get(':id') getOne(@Param('id') id: string) { return this.docService.find(id); }\n   }\n   ```  \n3. **Consistent Naming**  \n   - Rationale: discoverability.  \n   - Services suffixed `Service`, DTOs suffixed `Dto`, Entities suffixed `Entity`.  \n4. **Centralized Configuration**  \n   - Rationale: avoids magic literals.  \n   ```ts\n   // MUST: use ConfigService\n   this.configService.get<number>('PDF_TIMEOUT_SECONDS');\n   ```  \n5. **No `any` or Undeclared Variables**  \n   - Rationale: preserves type safety.  \n\n### MUST NOT Do  \n1. **Monolithic Files**  \n   ```ts\n   // MUST NOT: 500+ line file\n   export class UtilityLivingInEveryCorner { /* ... */ }\n   ```  \n   - Anti‐pattern: violates SRP & hard to navigate.  \n2. **Direct Database Calls in Controllers**  \n   ```ts\n   // MUST NOT\n   @Controller('user')\n   export class BadController {\n     @Get() find() { return this.repo.query('SELECT * FROM user'); }\n   }\n   ```  \n   - Fix: delegate to Service & Repository layers.  \n3. **Inline CSS or Magic Classnames**  \n   ```jsx\n   // MUST NOT\n   <div className=\"p-3 bg-gray-300 rounded text-sm\">…\n   ```  \n   - Fix: use Tailwind ‘@apply’ in a `.css` file or extract to component.  \n4. **Console Logging in Production Code**  \n   - Use NestJS Logger or a centralized logging service.  \n5. **Blocking Calls for PDF Generation**  \n   - Always push to queue (AWS SQS) and respond asynchronously.  \n\n## 5. Architecture Patterns  \n\n### 5.1 Module & Component Structure  \n- **Domain Modules**: one NestJS module per domain (auth, document, audit, admin).  \n- **Feature Folders** in Next.js: group page+components+styles per route if >3 components.  \n- **Shared Libraries**: extract common code to `@common` / `src/utils`.  \n\n### 5.2 Data Flow  \n- **Frontend**:  \n  - Use React Query’s `useQuery`/`useMutation`.  \n  - No global state library for server data.  \n- **Backend**:  \n  - Controllers → Services → Repositories → Entities  \n  - External calls in `infrastructure` layer  \n\n### 5.3 State Management Conventions  \n- **React Query**:  \n  ```tsx\n  // MUST\n  const { data, error, isLoading } = useQuery(['document', id], () =>\n    docService.fetchDocument(id)\n  );\n  ```  \n- **Mutations** always invalidate related queries:  \n  ```tsx\n  // MUST\n  const mutation = useMutation(saveDoc, {\n    onSuccess: () => queryClient.invalidateQueries('documents')\n  });\n  ```  \n\n### 5.4 API Design Standards  \n- **RESTful Endpoints**: `/documents/{id}`, `/users/{id}/documents`  \n- **HTTP Status Codes**:  \n  - 200 OK, 201 Created, 204 No Content for deletes  \n  - 400 Bad Request for validation errors  \n  - 401 Unauthorized, 403 Forbidden, 404 Not Found  \n- **Request/Response DTOs** with Swagger decorators:  \n  ```ts\n  // MUST: NestJS DTO with validation\n  export class CreateDocumentDto {\n    @IsString() title: string;\n    @IsEnum(DocumentType) type: DocumentType;\n  }\n  ```  \n\n---\n\n## Example Snippets  \n\n```ts\n// MUST: NestJS Service with explicit types and single responsibility\n@Injectable()\nexport class UserService {\n  constructor(@InjectRepository(UserEntity) private repo: Repository<UserEntity>) {}\n  async findById(id: string): Promise<UserDto> {\n    const user = await this.repo.findOneOrFail(id);\n    return plainToClass(UserDto, user);\n  }\n}\n```\n\n```ts\n// MUST NOT: Any usage, broad return type, and inline SQL\nasync function badFetch(): Promise<any> {\n  const res = await this.repo.query('SELECT * FROM users');\n  return res;\n}\n```\n\n```jsx\n// MUST: Next.js page using React Query\nimport { useQuery } from 'react-query';\nimport { fetchDocument } from '@services/document';\nexport default function DocumentPage({ id }) {\n  const { data, isLoading, error } = useQuery(['doc', id], () => fetchDocument(id));\n  if (isLoading) return <Spinner />;\n  if (error) return <Error />;\n  return <DocumentViewer data={data} />;\n}\n```\n\n```jsx\n// MUST NOT: Fetching in `useEffect` with manual state\nfunction BadComponent({ id }) {\n  const [data, setData] = useState(null);\n  useEffect(() => {\n    fetch(`/api/documents/${id}`).then(r => r.json()).then(setData);\n  }, [id]);\n  return data ? <Viewer data={data} /> : <Spinner />;\n}\n```\n\n# End of Code Guidelines",
      "writedAt": "2025-07-19T08:17:17.563Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-19T08:17:17.563Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-19T08:17:17.563Z"
    }
  ]
}